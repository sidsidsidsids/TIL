# 

# TIL

## 순서가 없는 데이터 구조

### Set

> 중복되는 요소 없이 순서 상관없는 데이터들의 묶음
> 
> **순서가 없기 때문에 인덱스 불가**
> 
> 집합 연산 가능
> 
> 삽입 변경 및 삭제 가능 -> 가변 자료형 (mutable)

- copy() : 복사본을 반환함

- add(x) : x가 세트에 없다면 추가

- pop() : 세트에서 랜덤하게 항목을 반환하고 해당 항목을 제거

- remove(s) : 항목 x를 세트에서 삭제, x가 없다면 에러

- discard(x) : 항목 x를 세트에서 삭제

- update(t) : t에 있는 항목 중 세트에 없는 항목 추가

- clear() : 모든 항목 제거

- isdisjoint(t) : 세트가 t와 서로 같은 항목을 하나라도 갖고 있지 않으면 True (서로소)

- issubset(t) : 세트가 t의 하위 세트인 경우 True

- issuperset(t) : 세트가 t의 상위 세트인 경우 True

### Dict

> **순서가 없기 때문에 인덱스 불가**
> 
> key : string, int, float, boolean, tuple, range
> 
> values : 어떤 형태든 상관 없음

- clear() : 모든 항목을 제거

- copy() : 얕은 복사본을 반환

- **keys() : 모든 키를 담은 뷰를 반환**

- **values() : 모든 값을 담은 뷰를 반환**

- items() : 모든 키 값의 쌍을 담은 뷰를 반환

- **get(k) : 키 k 값을 반환, d가 없으면 None**

- **get(k, v) : 키 k 값을 반환, d가 없으면 v 반환**

- pop(k) : k 값을 반환하고 k를 딕셔너리에서 삭제, d가 없으면 keyError

- pop(k, v) : k 값을 반환하고 k를 딕셔너리에서 삭제, d가 없으면 v 반환

- update([other]) : d값을 매핑하여 업데이트

### 얕은 복사와 깊은 복사

- 할당
  
  > 완전히 동일한 메모리 주소에 담긴 객체를 가리킴

- 얕은 복사
  
  > 복사본이 같은 데이터(주소)를 보고 있음 (해당 객체의 주소만을 복사)
  > 
  > 객체안 객체. 내부 객체는 원본과 동일한 주소를 가리키는 객체

- 깊은 복사
  
  > 데이터를 복사하여 다른 곳에 보관 (새로운 자료공간을 갖는다)
  > 
  > 객체 안의 객체, 내부 객체까지 모두 copy

- 복사 방법
  
  - 할당
    
    - 대입 연산자 (=) : 해당 객체에 대한 객체 참조를 복사
    
    - Slice [:] : 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)
      
      - 다른 주소인데 왜 얕은 복사? -> 복사하는 리스트의 원소가 같은 주소 참조하는 경우가 있음 (부분적으로는 깊은 복사)
        (ex : [1, 2, [a,b]] 리스트를 복사할 때 [a,b]의 주소가 똑같음)
  
  - 깊은 복사
    
    - ```python
      import copy
      a = [1, 2, [a,b]]
      b = copy.deepcopy(a)
      ```
    
    - 메모리 용량을 많이 사용함   

### import module

- 장점 : 유지보수 비용(휴먼리소스) 감소
  
  - `import random`
    
    - 단점
    
    - 모듈.함수 -> DRY 원칙 모듈 반복도 원칙에 어긋남




