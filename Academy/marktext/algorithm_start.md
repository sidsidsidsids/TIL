# START

### SW 문제 해결

- 프로그래밍하기 위한 제약 조건과 요구 사항
  
  - 프로그래밍 언어 특성, 프로그램이 동작할 HW와 OS에 관한 지식, 라이브러리 유의 사항들, 프로그램이 사용할 수 있는 최대 메모리, 사용자 대응 시간 제한, 재사용성 높은 코드 등..

- 문제 해결 역량
  
  - **프로그램을 하기 위한 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 것**
  
  - 추상적인 기술이며 훈련이 필요함

### 복잡도 분석

- **알고리즘의 효율**
  
  - 공간적 효율성
    
    - 연산량 대비 얼마나 적은 메모리 공간을 요하는 가
  
  - 시간적 효율성
    
    - 연산량 대비 얼마나 적은 시간을 요하는 가
  
  - 시간적 복잡도 분석
    
    - 하드웨어/소프트웨어 환경에 따라 처리시간이 달라진다
      
      - 부동소수 처리 프로세서 존재 유무, 나눗셈 가속기능 유무
      
      - 프로그램 언어의 종류, 운영체제와 컴파일러의 종류
    
    - 이러한 차이로 인해 분석이 어려움 -> 점근적 표기
      
      - O(Big-Oh) 표기
        
        - 복잡도의 점근적 상한을 나타냄 (최대 이정도 시간까지 걸린다)
      
      - Ω(Big-Omega) 표기
        
        - 복잡도의 점근적 하한을 나타냄 (최소한 이만한 시간은 걸린다)
      
      - θ(Big=Theta) 표기
        
        - O와 Ω가 같은 경우에 사용함
    
    - 효율적 알고리즘의 필요성
      
      - 10억 개의 숫자를 정렬할 때 PC에서 O(n^2) 알고리즘은 300여 년이 걸리며 O(nlogn) 알고리즘은 5분만에 정렬한다
      
      - 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있으며 값 비싼 H/W 기술 개발보다 효율적인 알고리즘 개발이 훨씬 경제적이다

### 표준 입출력 방법

- Python3 표준입출력
  
  - 입력
    
    - Raw 값의 입력 : input()
      
      - 받은 입력값을 문자열로 취급
    
    - Evalueated된 값의 입력 : eval(input())
      
      - 받은 입력값을 평가된 데이터 형으로 취급
  
  - 출력
    
    - print()
      
      - 표준 출력 함수, 출력값의 마지막 개행 문자 포함
    
    - print('text', end='')
      
      - 출력 시 마지막 개행문자 제외할 시
    
    - print('%d' % number)
      
      - Formatting 된 출력
  
  - 파일 내용을 표준 입력으로 읽어오기
    
    - import sys
    
    - sys.stdin = open("a.txt", "r")

### 비트 연산

- 비트 연산자
  
  - & 
    
    - 비트단위로 AND 연산
  
  - |
    
    - 비트단위로 OR 연산
  
  - ^
    
    - 비트단위로 XOR 연산(같으면 0 다르면 1, 예 : 1 1 -> 0)
  
  - ~
    
    - 단항 연산자로 피연산자의 모든 비트를 반전
  
  - <<
    
    - 피연산자의 비트 열을 왼쪽으로 이동 (a << x : a * 2^x)
    - 1 << n : 2^n의 값을 가지며 원소가 n개일 경우의 모든 부분집합의 수를 의미함
    - i & (1<<j) : 계산 결과가 i의 j번째 비트가 1인지 아닌지를 의미함
  
  - '>>'
    
    - 피연산자의 비트 열을 오른쪽으로 이동

- 비트 연산 예제
  
  - ```python
    def Bbit_print(i)
        output = ''
        for j in range(7, -1, -1):
            output += "1" if i & (1 << j) else "0"
        print(output)
    
    for i in range(-5,6):
        print("%3d = " % i, end='') # %x : align output line
        Bbit_print(i)
    ```

- 엔디안
  
  - 빅 엔디안 : 보통 큰 단위가 앞에 나옴. 네트워크
  
  - 리틀 엔디안 : 작은 단위가 앞에 나옴. 데스크탑
  
  - | 종류     | 0x1234 | 0x12345678  |
    | ------ | ------ | ----------- |
    | 빅 엔디안  | 12 34  | 12 34 56 78 |
    | 리틀 엔디안 | 34 12  | 78 56 34 12 |
  
  - 확인 코드
    
    - ```python
      import sys
      print(sys.byteorder)
      ```

### 진수

> **2진수**, 8진수, **10진수**, **16진수**

- 진수변환
  
  - 10진수의 변환
    
    - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
      
      - ex) 149(10) = 10010101(2) = 225(8) = 95(16)
  
  - 10진수로의 변환
    
    - ex) 135(8) = 1 * 8^2 + 3 * 8^1 + 5 * 8^0 = 93(10)
    
    - ex) 135.12(8) = 1 * 8^2 + 3 * 8^1 + 5 * 8^0 + 1 * 8^(-1) + 2 * 8^(-2) = 93.15625(10)
  
  - 2진법 -> 세자리씩 묶음 -> 8진법, 8진법 -> 세자리씩 나열 -> 2진법
  
  - 2진법 -> 네자리씩 묶음 -> 16진법, 16진법 -> 네자리씩 나열 -> 2진법

- 음의 정수 표현
  
  - 1의 보수
    
    - 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다.
    
    - -6 : 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 : 부호와 절대값 표현
    
    - -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 : 1의 보수 표현
  
  - 2의 보수
    
    - 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다
    
    - -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 : 2의 보수 표현

### 실수

- 실수의 표현
  
  - 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating point) 표기법을 사용함
  
  - 소수점의 위치를 고정시켜 표현하는 방식
    
    - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현한다
    
    - 1001.0011 -> 1.0010011 * 2^3

- 저장 형식
  
  - 단정도 실수(32비트)
    
    - 부호 1비트, 지수 8비트, 가수 23비트
  
  - 배정도 실수(64비트)
    
    - 부호 1비트, 지수 11비트, 가수 52비트
  
  - 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
  
  - 지수부(exponenet): 실제 소수점의 위치를 지수 승으로 표현한 것
  
  - 단정도 실수의 가수 부분 만들기
    
    - ex) 1001.0011
    
    - 정수부의 첫 자리가 1이 되도록 오른쪽으로 시프트
    
    - 소수점 이하를 23비트로 만들고 소수점 이하만을 가수 부분에 저장
    
    - 지수 부분은 시프트 한 자릿수 만큼 증가 혹은 감소
      
      - ```markdown
        1001.0011
        0001.0010011
        0001.00100110000000000000000
        00100100110000000000000000
        -> 1.0010011 * 2^3
        ```
  
  - 단정도 실수의 지수 부분 만들기
    
    - 지수부에는 8비트가 배정
    
    - 숫자로는 0-255까지 나타낼 수 있지만 음수 값을 나타내야 하므로 익세스 표현
      
      - 익세스 표현 :
        
        - 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

- 컴퓨터
  
  - 컴퓨터는 실수를 근사적으로 표현한다
    
    - 이진법으로 표현할 수 없는 형태의 실수는 근사 값으로 저장되어 계산 과정에서의 작은 오차가 다른 결과를 가져올 수 있다
  
  - 실수 자료형의 유효 자릿수
    
    - 32 비트 실수형 유효자릿수(십진수) -> 6
    
    - 64 비트                    "                          -> 15
  
  - 파이썬에서는 내부적으로 더 많은 비트를 사용해서 훨씬 넓은 범위 실수 표현 가능
    
    - 최대 1.8 * 10^308, 이 이상은 inf (문제 풀이할 때는 inf 사용하지 말기)
    
    - 최소 5.0 * 10^(-324), 이 이하는 0으로 표현

# Computational Thinking

> 어떤 전공도 상식선에서 이해되는 분야는 없다

- 연산
  
  - 부정 NOT
    
    - p가 명제일 때, 명제의 진릿값이 반대
    
    - ~p 혹은 ㄱp로 표기
  
  - 논리곱 AND
    
    - p, q가 명제일 때 p, q 모두 참일 때만 참이 되는 명제
    
    - p ^ q (p and q)
  
  - 논리합 OR
    
    - p, q가 명제일 때 p, q 모두 거짓일 때만 거짓이 되는 명제
    
    - p V q (p or q)
  
  - 배타적 논리합 XOR
    
    - p, q가 명제일 때 p, q 모두 하나만 참일 때 참이 되는 명제
    
    - p ⊕ q (p xor q)
  
  - 연산자 우선 순위
    
    - ㄱ >  V, ^ > →, ↔

- 명제
  
  - ![](C:\Users\SSAFY\AppData\Roaming\marktext\images\2023-03-02-09-40-00-image.png)
    
    - T -> F 일 때에만 F, 나머지 경우 T
  
  - ![](C:\Users\SSAFY\AppData\Roaming\marktext\images\2023-03-02-10-00-56-image.png)

- 수와 표현
  
  - 컴퓨터는 0/1을 표현하는 비트들을 모아 수를 표현
  
  - 어떤 경우든 k개의 비트를 사용할 때 0부터 2^k-1까지 2^k가지의 값 표현 가능
  
  - 어떤 값 n을 표현하기 위해선..
    
    - 2^k - 1 >= n 이 성립해야 함. 즉, 2^k >= n+1
    
    - 같은 의미로 k >= log(n+1), 약 log n 비트 필요
    
    - x = log n 과 2^x = n 은 같은 말 (로그 밑 2 생략)

- 알고리즘의 시간 복잡도
  
  - n을 inf로 보냈을 때 상수가 어떻게 변하는지 보기

- 재귀
  
  - 자기 자신을 호출하는 함수를 의미, 끝내기 위해서는 다른 입력이 필요

- 동적 프로그래밍
  
  - 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것 (Memoization)
  
  - 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만 결과 값을 순서를 정해서 계산할 수도 있음 (Dynamic Programming)
