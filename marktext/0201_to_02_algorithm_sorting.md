# TIL

### 알고리즘의 성능

- 정확성
  
  - 얼마나 정확하게 동작하는가

- 작업량
  
  - 얼마나 적은 연산으로 원하는 결과를 얻는가

- 메모리 사용량
  
  - 얼마나 적은 메모리를 사용하는가

- 단순성
  
  - 얼마나 단순한가

- 최적성
  
  - 더 이상 개선할 여지없이 최적화되었는가

- 시간 복잡도 (Large O)
  
  - 알고리즘의 작업량을 표현하며 실제 걸리는 시간을 측정
  
  - 알고리즘의 작업량을 표현하며 실제 걸리는 시간을 측정
  
  - 실행되는 명령문의 개수를 계산

### 배열

- `arr = []` , `arr = [0]*10` 꼴로 1차원 배열 생성

- 최대값 max 안쓰고 구하기
  
  - `max = 0 ; if arr[i] > max : max = arr[i] `

### 정렬

- **Bubble Sort**
  
  - 인접한 두 개의 원소를 비교하며 자리를 계속 교환
  
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 맨 마지막 자리까지 이동함
  
  - O(n^2), n은 리스트 길이

- *Counting Sort*
  
  - 집합에 각 항목이 몇 개씩 있는지 세는 작업을 통해 선형 시간에 정렬
    
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  
  - O(n+k) , n은 리스트 길이, k는 정수의 최대값

- **Selection Sort**
  
  - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환
    
    - 최소값을 리스트의 맨 앞에 위치한 값과 교환하며 맨 앞을 줄이며 반복
    
    - k번째로 작거나 큰 값 찾을 때 유용
  
  - O(n^2), n은 리스트 길이

- Quick Sort

- Insertion Sort

- Merge Sort

### 접근 방법

- 완전 검색
  
  - 문제의 해법으로 생각할 수 있는 모든 경우의 수 나열 및 확인
  
  - 일반적으로 경우의 수가 상대적으로 작을 때 유용
  
  - 순열을 이용 (nPr)

- 탐욕 알고리즘 (Greedy)
  
  - 최적해를 구하는 데 사용되는 근시안적 방법
  
  - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라 생각하는 것을 선택해 나가는 방식으로 머릿속에 떠오른 생각을 검증 없이 바로 구현하는 것

### 2차원 배열

- 1차원 리스트를 묶어놓은 리스트

- 선언 : 세로길이(행의 개수), 가로길이(열의 개수)
  
  - 빈 배열 선언 : [ [0] * n for _ in range (n) ]

- 행 우선 순회
  
  - ```python
    for i in range(n):
        for j in range(m):
            Array[i][j]
    ```

- 열 우선 순회
  
  - ```python
    for j in range(m):
        for i in range(n):
            Array[i][j]
    ```

- 지그재그 순회
  
  - ```python
    for i in range(n):
        for j in range(m):
            Array[i][j + (m-1-2*j) * (i%2)]
    # i가 짝수일 때 [j + (m-1-2*j) * (i%2)] = j , j : 0 -> m-1
    # i가 홀수일 때 [j + (m-1-2*j) * (i%2)] = m-1 - j , j : m-1 -> 0
    ```

- 델타 이용 2차 배열 탐색 : 2차 배열의 한 좌표에서 4방향의 인접 배열 요소 탐색 방법
  
  - ```python
    '''
    arr[0...N-1][0...N-1] # N*N 배열
    di[] <- [0, 0, -1, 1] 
    dj[] <- [-1, 1, 0, 0] # 좌, 우, 상, 하
    for i : 0 -> N-1:
        for j : 0 -> N-1:
            for k in range(4):
                ni <- i + di[k]
                nj <- j + dj[k]
                if 0 <= ni < N and 0 <= nj < N # 유효한 인덱스인지 확인
                    test(arr[ni][nj])
    '''
    for i in range(N):
        for j in range(N):
            for di, dj in [[-1,0],[1,0],[0,-1],[0,1]]:
                ni, nj = i+di, j+dj
                if 0 <= ni < N and 0 <= nj < N:
                    print(i, j, ni, nj)
    ```
  
  - 이를 응용하여 상하좌우 뿐만 아니라 대각선, 8방향 등으로도 활용 가능
    
    - 8방향의 경우 그냥 사각형으로 인덱싱 하는게 더 편하긴 함

- 전치 행렬 (transpose)
  
  - ```python
    for i in range(n) :
        for j in range(m) :
            if i < j:
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    ```

### 부분 집합

> 부분집합의 수 : 집합의 원소가 n개일 때 공집합을 포함한 부분집합의 개수는 2^n개

- loop를 이용한 부분집합 확인 및 생성 방법
  
  - ```python
    bit = [0, 0, 0, 0]
    for i in range(2):
        bit[0] = i # 0번째 원소
        for j in range(2):
            bit[1] = j # 1번째 원소
            for k in range(2):
                bit[2] = k # 2번째 원소
                for l in range(2):
                    bit[3] = l # 3번째 원소
                    print_subset(bit) # 생성된 부분집합 출
    ```

### 비트 연산자

> 비트 : 단위
> 
> | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 1   |
> |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

- '&'' : 비트 단위로 AND 연산
  
  - i & (1<<j) : i의 j번째 비트가 1인지 아닌지 검사

- '|' : 비트 단위로 OR 연산

- '<<'' : 피연산자의 비트 열을 왼쪽으로 이동시킨다
  
  - 1 << n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수 의미

- '>>' : 비트 열을 오른쪽으로 이동시킨다

### 검색

> 저장되어 있는 자료 중 원하는 항목을 찾는 작업 (목적하는 탐색 키)
> 
> 순차 검색 / 이차 검색 / 해쉬

### 순차 검색

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법. '순차구조'로 구현된 자료에서 찾을 때 유용함

- 검색 대상이 많은 경우 수행시간이 급격히 증가하여 비효율적

- 검색 과정
  
  - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교
  
  - 찾으면 인덱스 반환, 없으면 실패

### 이진 검색

- 자료의 가운데 있는 항목의 키 값과 비교하여 다음 검색의 위치를 정하고 검색을 진행

- **자료가 정렬된 상태**일 때 가능

- 검색 과정
  
  - 자료의 중앙에 있는 원소를 골라 그 값과 목표 값을 비교
  
  - 목표 값이 더 작으면 왼쪽에 대해서 새로 검색, 더 크면 오른쪽에 대해서 새로 검색
  
  - 찾을 때까지 반복, 없으면 실패

### 인덱스

> 데이터베이스에서 유래했으며 테이블에 대한 동작 속도를 높여주는 자료 구조
> 
> 키-필드만을 갖고 있고 테이블의 다른 세부 항목들은 갖고 있지 않다

### 문자열

> 메모리는 숫자만을 저장할 수 있기 때문에 각 문자에 대응되는 숫자를 정하고 이를 메모리에 저장하는 방법으로 문자를 표현한다.
> 
> 문자 인코딩 표준 ASCII : 7bit 인코딩으로 128문자를 표현하며 33개의 출력 불가 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져있음
> 
> 유니코드 : 다국어 처리를 위해 만든 표준 문자

- 0과 1 두 가지의 값 중 하나를 저장하는 메모리 단위 Bit

- Bit룰 8개 묶은 것이 Byte
  
  - 보통 Byte 단위로 저장됨

- python에서의 문자열
  
  - char 타입 없음
  
  - 텍스트 데이터 취급방법 통일됨
  
  - 문자열 기호 : '(홑따옴표), "(쌍따옴표), '''(따옴표 3개)
    
    - += (연결) , *(반복)
  
  - replace(), split(), isalpha(), find()
  
  - 튜플과 같이 요소값을 변경 할 수 없음(immutable)
