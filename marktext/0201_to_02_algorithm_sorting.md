# TIL

### 알고리즘의 성능

- 정확성
  
  - 얼마나 정확하게 동작하는가

- 작업량
  
  - 얼마나 적은 연산으로 원하는 결과를 얻는가

- 메모리 사용량
  
  - 얼마나 적은 메모리를 사용하는가

- 단순성
  
  - 얼마나 단순한가

- 최적성
  
  - 더 이상 개선할 여지없이 최적화되었는가

- 시간 복잡도 (Large O)
  
  - 알고리즘의 작업량을 표현하며 실제 걸리는 시간을 측정
  
  - 알고리즘의 작업량을 표현하며 실제 걸리는 시간을 측정
  
  - 실행되는 명령문의 개수를 계산

### 배열

- `arr = []` , `arr = [0]*10` 꼴로 1차원 배열 생성

- 최대값 max 안쓰고 구하기
  
  - `max = 0 ; if arr[i] > max : max = arr[i] `

### 정렬

- **Bubble Sort**
  
  - 인접한 두 개의 원소를 비교하며 자리를 계속 교환
  
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 맨 마지막 자리까지 이동함
  
  - O(n^2), n은 리스트 길이

- *Counting Sort*
  
  - 집합에 각 항목이 몇 개씩 있는지 세는 작업을 통해 선형 시간에 정렬
    
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  
  - O(n+k) , n은 리스트 길이, k는 정수의 최대값

- **Selection Sort**

- Quick Sort

- Insertion Sort

- Merge Sort

### 접근 방법

- 완전 검색
  
  - 문제의 해법으로 생각할 수 있는 모든 경우의 수 나열 및 확인
  
  - 일반적으로 경우의 수가 상대적으로 작을 때 유용
  
  - 순열을 이용 (nPr)

- 탐욕 알고리즘 (Greedy)
  
  - 최적해를 구하는 데 사용되는 근시안적 방법
  
  - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라 생각하는 것을 선택해 나가는 방식으로 머릿속에 떠오른 생각을 검증 없이 바로 구현하는 것

### 2차원 배열

- 1차원 리스트를 묶어놓은 리스트

- 선언 : 세로길이(행의 개수), 가로길이(열의 개수)
  
  - 빈 배열 선언 : [ [0] * n for _ in range (n) ]

- 행 우선 순회
  
  - ```python
    for i in range(n):
        for j in range(m):
            Array[i][j]
    ```

- 열 우선 순회
  
  - ```python
    for j in range(m):
        for i in range(n):
            Array[i][j]
    ```

- 지그재그 순회
  
  - ```python
    for i in range(n):
        for j in range(m):
            Array[i][j + (m-1-2*j) * (i%2)]
    # i가 짝수일 때 [j + (m-1-2*j) * (i%2)] = j , j : 0 -> m-1
    # i가 홀수일 때 [j + (m-1-2*j) * (i%2)] = m-1 - j , j : m-1 -> 0
    ```

- 델타 이용 2차 배열 탐색 : 2차 배열의 한 좌표에서 4방향의 인접 배열 요소 탐색 방법
  
  - ```python
    '''
    arr[0...N-1][0...N-1] # N*N 배열
    di[] <- [0, 0, -1, 1] 
    dj[] <- [-1, 1, 0, 0] # 좌, 우, 상, 하
    for i : 0 -> N-1:
        for j : 0 -> N-1:
            for k in range(4):
                ni <- i + di[k]
                nj <- j + dj[k]
                if 0 <= ni < N and 0 <= nj < N # 유효한 인덱스인지 확인
                    test(arr[ni][nj])
    '''
    for i in range(N):
        for j in range(N):
            for di, dj in [[-1,0],[1,0],[0,-1],[0,1]]:
                ni, nj = i+di, j+dj
                if 0 <= ni < N and 0 <= nj < N:
                    print(i, j, ni, nj)
    ```
  
  - 이를 응용하여 상하좌우 뿐만 아니라 대각선, 8방향 등으로도 활용 가능
    
    - 8방향의 경우 그냥 사각형으로 인덱싱 하는게 더 편하긴 함

- 전치 행렬 (transpose)
  
  - ```python
    for i in range(n) :
        for j in range(m) :
            if i < j:
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    ```

### 부분 집합

> 부분집합의 수 : 집합의 원소가 n개일 때 공집합을 포함한 부분집합의 개수는 2^n개

- loop를 이용한 부분집합 확인 및 생성 방법
  
  - ```python
    bit = [0, 0, 0, 0]
    for i in range(2):
        bit[0] = i # 0번째 원소
        for j in range(2):
            bit[1] = j # 1번째 원소
            for k in range(2):
                bit[2] = k # 2번째 원소
                for l in range(2):
                    bit[3] = l # 3번째 원소
                    print_subset(bit) # 생성된 부분집합 출
    ```

### 비트 연산자

> 비트 : 단위
> 
> | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 1   |
> |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

- '&'' : 비트 단위로 AND 연산
  
  - i & (1<<j) : i의 j번째 비트가 1인지 아닌지 검사

- '|' : 비트 단위로 OR 연산

- '<<'' : 피연산자의 비트 열을 왼쪽으로 이동시킨다
  
  - 1 << n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수 의미

- '>>' : 비트 열을 오른쪽으로 이동시킨다
